---
title: DI String Match
tags: [Arrays, Two-Pointers]
---

import Tabs from "@theme/Tabs";
import TabItem from "@theme/TabItem";
import LiveCode from "@site/src/components/LiveCode";

You are given a string `s` of length n that acts as a sequence of instructions (Increase or Decrease) for constructing a permutation.

The goal is to **reconstruct a permutation, `perm`**, of length n+1, which contains **all integers in the range [0, n]**.

The relationship between adjacent elements in `perm` must satisfy the following rules based on the instruction string `s`:

* If `s[i] == 'I'` (Increase): Then perm[i] < perm[i + 1].
* If `s[i] == 'D'` (Decrease): Then perm[i] > perm[i + 1].

You need to return **any** valid permutation `perm` that satisfies these constraints.

<!-- truncate -->

<Tabs>
  <TabItem value="examples" label="Examples" defaultValue>
#### Example 1

* **Input:** `s = "IDID"`
* **Output:** `[0, 4, 1, 3, 2]`
* **Explanation:** The permutation starts with the smallest available number (0) for 'I', then the largest (4) for 'D', then the next smallest (1) for 'I', and so on, satisfying the pattern: 0 < 4 > 1 < 3 > 2.

#### Example 2

* **Input:** `s = "III"`
* **Output:** `[0, 1, 2, 3]`
* **Explanation:** Since all instructions are 'I', the permutation is strictly increasing, using the available numbers in order: 0 < 1 < 2 < 3.

#### Example 3

* **Input:** `s = "DDI"`
* **Output:** `[3, 2, 0, 1]`
* **Explanation:** The first two 'D' instructions use the largest numbers (3 then 2), and the final 'I' instruction uses the next smallest available number (0), followed by the remaining number (1) for the last slot: 3 > 2 > 0 < 1.
</TabItem>

<TabItem value="notes" label="Notes" >
  ## ðŸ’¡ Optimal Approach: The Greedy Two-Pointer Strategy

Since you only need to return **any valid permutation**, we can use a **greedy approach** combined with a **Two-Pointer technique** to construct the array sequentially.

The key idea is to use the **largest available number** whenever the instruction requires a **Decrease ('D')** and the **smallest available number** whenever the instruction requires an **Increase ('I')**. This greedy choice ensures a valid number is always available for the next step.

### Steps to Reconstruct `perm`

#### 1. Initialize Boundaries

* Set a pointer for the **smallest available number**, `low`, starting at **0**.
* Set a pointer for the **largest available number**, `high`, starting at **n** (which is `s.length`).
* Initialize the result array, `perm`, which will have n+1 elements.

#### 2. Iterate Through Instructions

Loop through the instruction string `s` from left to right (from i=0 to i=n-1).

* **If the instruction is 'I' (Increase):**
    * To satisfy `perm[i] < perm[i+1]`, choose the **smallest available number** for the current position `perm[i]`. This saves larger numbers for future 'D' requirements.
    * Set `perm[i] = low`.
    * Increment `low` by 1.

* **If the instruction is 'D' (Decrease):**
    * To satisfy `perm[i] > perm[i+1]`, choose the **largest available number** for the current position `perm[i]`. This ensures smaller numbers are available later to complete the decreasing sequence.
    * Set `perm[i] = high`.
    * Decrement `high` by 1.

#### 3. Handle the Last Element

* The loop runs only for n steps. The `perm` array needs n+1 elements.
* After the loop finishes, there will be exactly **one number left** (at this point, `low` and `high` will be equal).
* Set the final element, `perm[n]`, to this remaining number (low or high).

### Example Walkthrough

* **Input:** `s = "IDID"` (n=4). Permutation uses numbers in the range [0, 4].
* **Initial:** `low = 0`, `high = 4`, `perm = [?, ?, ?, ?, ?]`

| i | s[i] | Condition | Action | perm[i] | low | high | perm |
| :-: | :---: | :--- | :--- | :---: | :-: | :-: | :--- |
| **0** | **I** | Increase | Use `low` (0), `low++` | 0 | 1 | 4 | `[0, ?, ?, ?, ?]` |
| **1** | **D** | Decrease | Use `high` (4), `high--` | 4 | 1 | 3 | `[0, 4, ?, ?, ?]` |
| **2** | **I** | Increase | Use `low` (1), `low++` | 1 | 2 | 3 | `[0, 4, 1, ?, ?]` |
| **3** | **D** | Decrease | Use `high` (3), `high--` | 3 | 2 | 2 | `[0, 4, 1, 3, ?]` |
| **4** | (End) | Final | Use remaining `low` (2) | 2 | 2 | 2 | `[0, 4, 1, 3, 2]` |

* **Resulting Permutation:** `[0, 4, 1, 3, 2]`
</TabItem>

<TabItem value="try" label="Try">
  <LiveCode
    code={`
let diStringMatch = (str) => {
 // Your code goes here
};

diStringMatch("IDID") // [0, 4, 1, 3, 2]

`}
  />
</TabItem>


<TabItem value="solution" label="Solution" >
```jsx 
let diStringMatch = function(s) {
    let low = 0; // Pointer for the smallest available number
    let high = s.length; // Pointer for the largest available number (n)
    let perm = []; // The resulting permutation array
    
    // Loop only over the string s (n times)
    for (let i = 0; i < s.length; i++) {
        
        // If 'I' (Increase) is required, use the smallest available number (low)
        if (s[i] === 'I') {
            perm.push(low);
            low++;
        } 
        
        // If 'D' (Decrease) is required, use the largest available number (high)
        else if (s[i] === 'D') {
            perm.push(high);
            high--;
        }
        // No need for 'else' since the input only contains 'I' and 'D'
    }
    
    // After the loop, exactly one number remains (low will equal high).
    // This number is the (n+1)th element of the permutation.
    perm.push(low); 
    
    return perm;
};

```
</TabItem>

</Tabs>

