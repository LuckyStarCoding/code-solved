---
slug: blog/2025/maximum-sum-in-contiguous-array
title: Maximum Sum in Contiguous Array (Kadane's Algorithmn)
authors: [luckystar]
tags: [jstask, 2025, Arrays]
date: 2025-10-23
---

import Tabs from "@theme/Tabs";
import TabItem from "@theme/TabItem";

Given an array of integers numbers, determine the subarray that has the highest sum and return that sum.

A subarray is a contiguous segment of an array where all elements are taken from consecutive indices, 
preserving their order, such as [2, 3] in [1, 2, 3, 4], while non-contiguous selections like [1, 3] are not valid subarray.

<!-- truncate -->

<Tabs>
  <TabItem value="examples" label="Examples" defaultValue>
* maxSumSubArray([-1,5,-3,9,-11]) ➞ 11
  // Explanation: The subarray [5, -3, 9] has the largest sum i.e 11.
* maxSumSubArray([9]) ➞ 9
* maxSumSubArray([[1,2,3,4]]) ➞ 10

</TabItem>
<TabItem value="notes" label="Notes" >
  This task must be solved using Kadane's Algorithm.
  This algorithm uses a dynamic programming approach to solve the problem in a single pass. 
  It keeps track of two things as it iterates:

1. `max_current`: The maximum sum of a subarray ending at the current position.
2. `max_global`: The overall maximum sum found so far.

</TabItem>
<TabItem value="solution" label="Solution" >
```jsx 
function maxSumSubArray(nums) {
    // Handle the edge case of an empty array
    if (nums.length === 0) {
        return 0;
    }

    // Initialize both variables with the first element. 
    // This is crucial for handling arrays with negative numbers.
    let max_current = nums[0];
    let max_global = nums[0];

    // Start iterating from the second element (index 1)
    for (let i = 1; i < nums.length; i++) {
        const num = nums[i];

        // 1. Calculate the maximum sum ending at the current position ('i').
        // max_current is either:
        //   * The current number itself (starting a new subarray)
        //   * The current number PLUS the previous max_current (extending the old subarray)
        max_current = Math.max(num, num + max_current);

        // 2. Update the overall maximum sum found so far.
        if (max_current > max_global) {
            max_global = max_current;
        }
    }

    return max_global;
}
```
</TabItem>

</Tabs>

