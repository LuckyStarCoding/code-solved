---
slug: blog/2025/search-in-rotated-sorted-array
title: Search in Rotated Sorted Array
authors: [luckystar]
tags: [jstask, 2026]
date: 2026-01-20
---

import Tabs from "@theme/Tabs";
import TabItem from "@theme/TabItem";
import LiveCode from '@site/src/components/LiveCode';

There is an integer array `nums` sorted in ascending order (with **distinct** values). 
Prior to being passed to your function, `nums` is possibly rotated at an unknown pivot index `k`.

**Example:** The array `[0,1,2,4,5,6,7]` might become `[4,5,6,7,0,1,2]` if rotated at pivot index `3`.

<!-- truncate -->

### Objective
Given the array `nums` after the possible rotation and an integer `target`:
* Return the **index** of `target` if it is in `nums`.
* Return `-1` if it is not in `nums`.

### Complexity Requirement
To solve this efficiently, the algorithm should aim for a runtime complexity of `O(\log n)`.

## Logic Validation

Use the following test cases to verify your implementation. Since the array is sorted (but rotated), these cases cover the typical pivot points and edge cases.

| Input (`nums`, `target`) | Expected Output | Reasoning |
| :--- | :---: | :--- |
| `[4, 5, 6, 7, 0, 1, 2]`, `0` | `4` | `0` is at index 4. |
| `[4, 5, 6, 7, 0, 1, 2]`, `3` | `-1` | `3` does not exist in the array. |
| `[1]`, `0` | `-1` | Single element doesn't match target. |
| `[6, 7, 1, 2, 3, 4, 5]`, `6` | `0` | Target is the first element after rotation. |

---

### Implementation Notes

To maintain the required `O(\log n)` time complexity, your solution should utilize a **Modified Binary Search**. 

1. Find the middle element `mid`.
2. Determine which half is "properly sorted" (left or right).
3. Check if the `target` lies within the range of that sorted half.
4. Adjust your search boundaries accordingly.

<Tabs>
  <TabItem value="examples" label="Examples" defaultValue>

| Input (`nums`, `target`) | Expected Output | Reasoning |
| :--- | :--- | :--- |
| `[4, 5, 6, 7, 0, 1, 2]`, `0` | `4` | `0` is at index 4. |
| `[4, 5, 6, 7, 0, 1, 2]`, `3` | `-1` | `3` does not exist in the array. |
| `[1]`, `0` | `-1` | Single element doesn't match target. |
| `[6, 7, 1, 2, 3, 4, 5]`, `6` | `0` | Target is the first element after rotation. |

</TabItem>
<TabItem value="notes" label="Try" >
<LiveCode code={`
let find = (nums, t) => {
 // Your code goes here
};

find([4, 5, 6, 7, 0, 1, 2], 0)

`} />
</TabItem>
<TabItem value="solution" label="Solution" >
```jsx 
/**
 * Searches for a target in a rotated sorted array.
 * Time Complexity: O(log n)
 * Space Complexity: O(1)
 */
let find = (nums, t) => {
    // SECURITY CHECK: Defensive programming. 
    // Prevents "TypeError: Cannot read property 'length' of null"
    if (!nums || nums.length === 0) return -1;

    let low = 0;
    let high = nums.length - 1;

    while (low <= high) {
        // Calculate midpoint safely to avoid potential float issues in JS
        let m = Math.floor(low + (high - low) / 2);

        // Found the target immediately
        if (nums[m] === t) return m;

        // PATTERN: In a rotated array, at least one half must be sorted.
        
        // CASE 1: The Left side [low...m] is sorted
        if (nums[low] <= nums[m]) {
            // Is target within the boundaries of the sorted left half?
            if (t >= nums[low] && t < nums[m]) {
                high = m - 1; // Narrow search to the left
            } else {
                low = m + 1;  // Target must be in the right (unsorted) half
            }
        } 
        // CASE 2: The Right side [m...high] must be the sorted one
        else {
            // Is target within the boundaries of the sorted right half?
            if (t > nums[m] && t <= nums[high]) {
                low = m + 1;  // Narrow search to the right
            } else {
                high = m - 1; // Target must be in the left (unsorted) half
            }
        }
    }

    // Target not found after exhausting the search space
    return -1;
}

// Execution
find([4, 5, 6, 7, 0, 1, 2], 0);
```
</TabItem>

</Tabs>

