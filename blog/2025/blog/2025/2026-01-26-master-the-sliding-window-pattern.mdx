---
slug: blog/2025/master-the-sliding-window-technique
title: Mastering the Sliding Window Technique
authors: [luckystar]
tags: [jstask, 2026, Sliding Window]
date: 2026-01-26
---

import Tabs from "@theme/Tabs";
import TabItem from "@theme/TabItem";
import LiveCode from "@site/src/components/LiveCode";

If Binary Search is about cutting the search space in half, and Two Pointers is about meeting in the middle, then the **Sliding Window** is about "zooming in" on a specific segment of your data.

**The "Aha!" Moment**

Imagine you are looking at a long train through a small window. You can only see 3 cars at a time. To see the next set, you don't walk to a new window; you just "slide" the train forward.
In coding, we use this to find a **contiguous** (connected) subarray or substring that meets a goal. There are two types of windows: a Fixed Window and a Dynamic Window.

## **Type A: Fixed Window**
The size of the window is set (e.g., "Find the maximum sum of 3 consecutive numbers").

**Logic:** You calculate the sum of the first 3. To get the next sum, you add the next number and subtract the one that just left the window. Let's look at a concrete example.

**The Scenario**
* **Goal:** Find the sum of every contiguous subarray of size **k = 3**.
* **Array:** `[1, 3, 2, 6, -1, 4]`

#### **1. The "Naive" Way (Slow)**
A junior developer might do this:
* **Window 1:** 1 + 3 + 2 = 6
* **Window 2:** 3 + 2 + 6 = 11
* **Window 3:** 2 + 6 + (-1) = 7

**The Problem:** Notice how we added 3 + 2 in the first window, and then added 3 + 2 again in the second window? On a massive array, you‚Äôre wasting millions of additions.

#### **2. The "Rolling Sum" Way (Fast)**
We only calculate the first window fully. After that, we just update it.

1. **Initial Window (Indices 0, 1, 2):**
   1 + 3 + 2 = 6 (**oldSum**)
2. **Slide to Window 2 (Indices 1, 2, 3):**
   We "depart" the 1 and "add" the 6.
   **6 (oldSum) + 6 (next) - 1 (departed) = 11**
3. **Slide to Window 3 (Indices 2, 3, 4):**
   We "depart" the 3 and "add" the -1.
   **11 (oldSum) + (-1) (next) - 3 (departed) = 7**

#### Why this is a Security/Performance Win

Imagine the array has 1,000,000 elements and k = 1,000.

| Method | Operations | Performance Impact |
| :--- | :--- | :--- |
| **Naive** | 1,000,000,000 | Can hang browser/server |
| **Sliding Window** | 2,000,000 | Finishes in milliseconds |

In a production environment, an **O(n * k)** algorithm can be exploited. An attacker could send a request with a very large k, causing your server's CPU to spike to 100%, effectively performing a **Denial of Service (DoS)** attack.

---

#### üíª Code Example (Fixed Window)

```javascript
function maxSubarraySum(arr, k) {
    if (arr.length < k) return 0;

    let maxSum = 0;
    let tempSum = 0;

    // 1. Calculate the very first window
    for (let i = 0; i < k; i++) {
        maxSum += arr[i];
    }

    tempSum = maxSum;

    // 2. Start sliding from index 'k'
    for (let i = k; i < arr.length; i++) {
        // newSum = oldSum + nextNumber - departedNumber
        tempSum = tempSum + arr[i] - arr[i - k];
        maxSum = Math.max(maxSum, tempSum);
    }

    return maxSum;
}

console.log(maxSubarraySum([1, 3, 2, 6, -1, 4], 3)); // Output: 11
```

<details>
  <summary>The Task: Fixed Window Average</summary>

You are building a monitoring tool for a server. You are given an array of CPU usage percentages (0-100) and a window size **k**. You need to find the maximum average CPU usage over any contiguous period of length **k**.

---
#### Example
**Input:** `nums = [1, 12, -5, -6, 50, 3]`, `k = 4`

**Output:** `12.75`

**Reasoning:** The window `[12, -5, -6, 50]` has the sum **51**. Dividing the sum by the window size (**51 / 4**) results in **12.75**. This is the highest average possible for this array.

---
#### Implementation Tip
When solving this, remember to:
1.  Calculate the sum of the first **k** elements.
2.  Slide the window by adding the next element and subtracting the one that is no longer in the window.
3.  Keep track of the maximum sum found to determine the highest average.

### Implementation

This function uses the **Sliding Window** technique to find the maximum average of any contiguous subarray of size `k` with O(n) time complexity.

```javascript
/**
 * @param {number[]} nums
 * @param {number} k
 * @return {number}
 */
let findAvg = (nums, k) => {
    let currentSum = 0;

    // 1. Calculate the first window sum
    for (let i = 0; i < k; i++) {
        currentSum += nums[i];
    }

    // 2. Initialize maxSum with the first window's result
    let maxSum = currentSum;

    // 3. Slide the window
    for (let i = k; i < nums.length; i++) {
        // Add the new element, subtract the departed element
        currentSum = currentSum + nums[i] - nums[i - k];
        
        // Update the maximum SUM found so far
        if (currentSum > maxSum) {
            maxSum = currentSum;
        }
    }
    
    // 4. Divide ONCE at the very end to get the maximum average
    return maxSum / k;
}

console.log(findAvg([1, 12, -5, -6, 50, 3], 4)); // Output: 12.75
```
</details>

-----

### **Type B: Dynamic (Variable) Window**

The Dynamic (Variable-Size) Sliding Window is often called the "Accordion" algorithm. Unlike the Fixed Window where the size is constant, the Dynamic Window expands and shrinks like an accordion to find the smallest or largest segment that satisfies a specific condition.

It is the most efficient way to solve problems involving "subarrays" or "substrings" where the length of that subarray isn't known beforehand.

#### The Core Logic: "Expand until valid, Shrink until invalid"

The algorithm uses two pointers: a **right pointer** to lead the expansion and a **left pointer** to handle the contraction.

**Phase 1:** Expansion (The Right Pointer)
You move the right pointer forward, adding elements to your "window" (summing numbers, counting characters, etc.) until your condition is finally met (e.g., "The sum is now >= 10").

**Phase 2:** Contraction (The Left Pointer)
Now that the condition is met, you try to make the window as small as possible. You move the left pointer forward, removing elements from the back of the window one by one, as long as the condition remains met.

**Phase 3:** Update
Every time you find a "valid" window during the contraction phase, you record its length (or whatever the goal is).

### The Inchworm Strategy: Dynamic Sliding Window

**Complexity:** üöÄ Time: O(n) | üíæ Space: O(1)

The Dynamic Sliding Window (or "The Accordion") is the most efficient way to find a specific segment of data when you don't know how long that segment should be.

#### üìù Task Description
Given an array of positive integers and a target value `t`, find the **minimal length** of a contiguous subarray whose sum is **greater than or equal to** `t`. If no such subarray exists, return 0.

#### üêõ The "Inchworm" Logic
Think of the algorithm as an inchworm moving across a leaf. It doesn't move its whole body at once; it moves in two distinct "slow-mo" steps:

1.  **The Head (Expansion):** The `head` stretches forward to grab more "leaf" (adding numbers to the sum via a `for` loop).
2.  **The Tail (Contraction):** Once the `head` reaches the goal, the `tail` pulls forward to shrink the body as much as possible while the condition is still met (via a `while` loop).

> **Why this works:** Instead of starting over from scratch, the Head and Tail only ever move forward. Every number is visited exactly twice, making the process incredibly fast.

<Tabs>

<TabItem value="try" label="Try">
    <LiveCode
      code={`// Write your solution here
const findMinLength = (nums, t) => {
  
};
`}
    />
  </TabItem>

<TabItem value="solution" label="Solution">
    ```javascript
const findMinLength = (nums, t) => {
  let tail = 0; // The back of the inchworm
  let sum = 0;
  let minLen = Infinity;

  // 'head' is our Leader, stretching forward across the leaf
  for (let head = 0; head < nums.length; head++) {
    
    // 1. Inchworm Head stretches: Grab the next element
    sum += nums[head];

    // 2. Inchworm Tail pulls forward:
    // While our "body" is big enough to satisfy the target 't'...
    while (sum >= t) {
      
      // Calculate current body length: distance between Head and Tail
      let currentBodyLength = head - tail + 1;
      
      // Update our record if this is the smallest version yet
      minLen = Math.min(minLen, currentBodyLength);

      // 3. Shrink: The Tail pulls forward, leaving its current spot
      sum -= nums[tail];
      tail++;
    }
  }

  // If the inchworm never reached the target 't', return 0
  return minLen === Infinity ? 0 : minLen;
};

console.log(findMinLength([2, 3, 1, 2, 4, 3], 7)); // Output: 2
```
  </TabItem>
</Tabs>

<details>
  <summary>Inchworm in slow-mo</summary>

The Dynamic Sliding Window is a strategy used to find a specific segment of an array. It is like an inchworm moving across a leaf.

#### 1. The "Inchworm" Movement
An inchworm doesn't move its whole body at once. It moves in two distinct steps:
* **The Head (Right Pointer):** It stretches forward to grab more leaf.
* **The Tail (Left Pointer):** It pulls itself forward to shrink the body.

#### 2. The Game Rules
Imagine I give you this array: `[2, 3, 1, 2, 4, 3]` and I say:
> "Find the shortest distance that adds up to at least 7."

Here is how the Inchworm (your algorithm) thinks:

##### Step A: Stretch the Head (The for loop)
The head moves forward one index at a time. It keeps track of the sum of the body.
* Head grabs 2. Sum = 2. (Not enough).
* Head grabs 3. Sum = 5. (Not enough).
* Head grabs 1. Sum = 6. (Not enough).
* Head grabs 2. Sum = 8. **STOP!** 8 is >= 7. We hit the goal.



##### Step B: Pull the Tail (The while loop)
Now the head stays still. The Tail starts moving forward to see if the inchworm can be shorter while still covering at least 7.
* Tail was at the start (index 0). It moves forward, leaving the 2 behind.
* New Sum: 8 - 2 = 6.
* **Wait!** 6 is less than 7. The tail stops. The inchworm needs to be longer again.



##### Step C: Stretch the Head again
* Head grabs 4. Sum: 6 + 4 = 10. **STOP!** Goal met.
* Tail moves forward, leaving the 3 behind.
* New Sum: 10 - 3 = 7. **STILL GOOD!**

**Result:** We just found a body length of 3 ([1, 2, 4]).
</details>  

#### üõ°Ô∏è Guardrails
  - **Initialization:** We initialize `minLen` to `Infinity`. This ensures that any real array length we find will be smaller.
  - **Positive Numbers:** This specific "Inchworm" logic requires positive integers. If the array had negative numbers, adding a number might make the sum *smaller*, breaking the expansion logic.
  - **Performance Security:** Because the Tail never "resets" to zero, this is an **O(n)** operation. A nested loop approach would be **O(n¬≤)**, which could crash your server if an attacker sends a massive array.

### üéØ The Sliding Window Cheat Sheet

Not sure which "Inchworm" to use? Here is the quick-reference guide for your next coding interview or project.

| Feature | Fixed Window | Dynamic (Inchworm) |
| :--- | :--- | :--- |
| **Window Size** | Constant (k) | Variable (Expands/Shrinks) |
| **Movement** | Head & Tail move together | Head moves, then Tail "catches up" |
| **Logic Type** | `if` (one slide per step) | `while` (shrink until valid) |
| **Best For...** | "Find the avg of every 3 nums" | "Find the shortest segment..." |

### üêõ 3 Rules of the Inchworm
1. **The Head Always Leads:** Move the `head` pointer in a standard `for` loop to explore new data.
2. **The While Loop is the Filter:** Use a `while` loop to shrink the `tail` whenever your condition is met (or exceeded).
3. **Sync Your State:** If you use a Map or a Counter, you **must** update it when the `tail` moves. If a count hits zero, **delete the key** to avoid memory leaks.

---

### üõ°Ô∏è Final Security Checklist
Before you ship your Sliding Window code, ask yourself:
* [ ] **Is my Tail moving?** Ensure `tail++` is inside the `while` loop to avoid infinite loops.
* [ ] **Is my Map clean?** Check for "Ghost" keys that could cause memory exhaustion.
* [ ] **Are my inputs positive?** If the window relies on a growing sum, ensure your data doesn't contain negative numbers that break the logic.

<details>
  <summary>The Challenge: Maximum Fruits in Basket</summary>

Imagine you are walking along a row of fruit trees. Each tree has a specific type of fruit (represented by an integer). You have **two baskets**, and each basket can only hold **one type** of fruit. There is no limit on the amount of fruit each basket can hold, but you can't pick from a third type.

**Goal:** Find the maximum number of fruits you can collect in a row (contiguous) using only your two baskets.

**Example:**
* **Input:** `fruits = [1, 2, 1, 2, 3]` 
* **Output:** `4`
* **Reasoning:** You can pick `[1, 2, 1, 2]`. Once you hit `3`, you would have three types, which isn't allowed!

#### üí° Inchworm Strategy for this Problem

To solve this, our Inchworm needs a "Memory" (a Map) to know what's inside its baskets.

1.  **The Head (Expand):** Keep moving forward and adding fruits to a Map to keep track of how many types you have.
2.  **The Goal/Condition:** You are "Valid" as long as your Map has **2 or fewer** types.
3.  **The Tail (Shrink):** If your Map hits **3 types**, pull the tail forward. Subtract the fruit count at the tail. If a fruit's count hits 0, remove that type from your Map entirely so the size drops back to 2.
4.  **Update:** After each move (and potential shrink), record the max window size: `max = Math.max(max, head - tail + 1)`.

<Tabs>
<TabItem value="try" label="Try">
    <LiveCode
      code={`// Write your solution here
const solve = (nums) => {
  
};
`}
    />
  </TabItem>

  <TabItem value="solution" label="Solution">
```javascript
const totalFruit = (tree) => {
  let m = new Map();
  let max = 0;
  let tail = 0;

  for (let head = 0; head < tree.length; head++) {
    // 1. Head stretches: Add fruit to the basket
    let fruit = tree[head];
    m.set(fruit, (m.get(fruit) || 0) + 1);

    // 2. Shrink: If we have more than 2 types, pull the tail
    while (m.size > 2) {
      let leftFruit = tree[tail];
      m.set(leftFruit, m.get(leftFruit) - 1);
      
      // CRITICAL: Clean up the "Ghost Fruit"
      if (m.get(leftFruit) === 0) {
        m.delete(leftFruit);
      }
      tail++;
    }

    // 3. Update the maximum fruits collected
    max = Math.max(max, head - tail + 1);
  }

  return max;
};
    ```
  </TabItem>
</Tabs>
</details>
