---
slug: blog/2025/disjoint-intervals
title: Disjoint Intervals
authors: [luckystar]
tags: [jstask, 2025, Intervals]
date: 2025-10-20
---

import Tabs from "@theme/Tabs";
import TabItem from "@theme/TabItem";

Given an array of intervals where each interval is represented as [start, end]. Each pair denotes the start and end of an interval on a number line. For example, [1, 3] represents an interval that starts at 1 and ends at 3.
Find the minimum number of intervals that need to be removed so that the remaining intervals are disjoint.
Intervals are considered disjoint if no two intervals overlap on the number line. For example:
* [1, 3] and [4, 6] are disjoint because they do not share any common points
* [1, 5] and [4, 6] are not disjoint because they overlap at points between 4 and 5

<!-- truncate -->

<Tabs>
  <TabItem value="examples" label="Examples" defaultValue>
* disjointIntervals([[1,5],[2,3],[3,4],[4,6]]) ➞ 1
* disjointIntervals([[1,5],[2,3],[3,4],[4,6]]) ➞ 2
* disjointIntervals([[1,4],[4,8]]) ➞ 0
np
</TabItem>

<TabItem value="solution" label="Solution" >
```jsx 
function disjointIntervals(iv) {
    // 1. GREEDY CHOICE: Sort the intervals by their **ending time**.
    // This is the core of the greedy strategy: prioritizing intervals that finish earliest
    // leaves the maximum amount of time/space available for subsequent intervals.
    iv.sort((a, b) => a[1] - b[1]);

    // Handle edge case of empty input
    if (iv.length === 0) {
        return 0;
    }

    // c: Count of the **maximum number of non-overlapping intervals** selected.
    // We start at 1 because the first interval after sorting is always selected.
    let c = 1;

    // lastEnd: Stores the end time of the most recently selected non-overlapping interval.
    // This is the reference point for checking overlaps with future intervals.
    let lastEnd = iv[0][1];

    // 2. ITERATE AND SELECT NON-OVERLAPPING INTERVALS
    // Note: The loop starts from the first element (i=0) to include the initial check,
    // though the initialization already accounts for the first selected interval.
    // A slightly optimized loop would start at i=1, as iv[0] is already selected.
    for (let i = 0; i < iv.length; i++) {
        // Check if the current interval's start time is greater than or equal to
        // the end time of the last selected interval.
        // iv[i][0] >= lastEnd means the current interval is **disjoint** (non-overlapping)
        // with the previously selected set.
        if (iv[i][0] >= lastEnd) {
            // Found a non-overlapping interval:
            // a. Increment the count of selected non-overlapping intervals.
            c += 1;
            // b. Update the reference end time to the end of this newly selected interval.
            lastEnd = iv[i][1];
        }
        // If they overlap (iv[i][0] < lastEnd), we do nothing;
        // this interval is implicitly "removed" and not counted towards 'c'.
    }

    // 3. CALCULATE MINIMUM REMOVALS
    // The result is the total number of intervals minus the maximum number
    // of non-overlapping intervals we managed to select.
    return iv.length - c;
}

```
</TabItem>

</Tabs>

